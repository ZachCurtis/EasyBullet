"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[424],{3905:(e,t,l)=>{l.d(t,{Zo:()=>c,kt:()=>m});var n=l(7294);function a(e,t,l){return t in e?Object.defineProperty(e,t,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[t]=l,e}function r(e,t){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),l.push.apply(l,n)}return l}function o(e){for(var t=1;t<arguments.length;t++){var l=null!=arguments[t]?arguments[t]:{};t%2?r(Object(l),!0).forEach((function(t){a(e,t,l[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):r(Object(l)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(l,t))}))}return e}function i(e,t){if(null==e)return{};var l,n,a=function(e,t){if(null==e)return{};var l,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)l=r[n],t.indexOf(l)>=0||(a[l]=e[l]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)l=r[n],t.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(a[l]=e[l])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),l=t;return e&&(l="function"==typeof e?e(t):o(o({},t),e)),l},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var l=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(l),h=a,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||r;return l?n.createElement(m,o(o({ref:t},c),{},{components:l})):n.createElement(m,o({ref:t},c))}));function m(e,t){var l=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=l.length,o=new Array(r);o[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<r;u++)o[u]=l[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,l)}h.displayName="MDXCreateElement"},8861:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var n=l(7462),a=(l(7294),l(3905));const r={sidebar_position:1},o="EasyBullet API",i={unversionedId:"api/easyBullet",id:"api/easyBullet",title:"EasyBullet API",description:"Table of Contents",source:"@site/docs/api/easyBullet.md",sourceDirName:"api",slug:"/api/easyBullet",permalink:"/EasyBullet/docs/api/easyBullet",draft:!1,editUrl:"https://github.com/ZachCurtis/EasyBullet/docs/docs/api/easyBullet.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"API",permalink:"/EasyBullet/docs/category/api"},next:{title:"EasyBullet Settings",permalink:"/EasyBullet/docs/api/easyBulletSettings"}},s={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"FireBullet()",id:"fireBullet",level:3},{value:"BindCustomCast()",id:"bindCustomCast",level:3},{value:"BindShouldFire()",id:"bindShouldFire",level:3},{value:"Events",id:"events",level:2},{value:"BulletHit",id:"bullethit",level:3},{value:"BulletHitHumanoid",id:"bullethithumanoid",level:3},{value:"BulletUpdated",id:"bulletupdated",level:3}],c={toc:u},d="wrapper";function p(e){let{components:t,...l}=e;return(0,a.kt)(d,(0,n.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"easybullet-api"},"EasyBullet API"),(0,a.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#constructor"},"Constructor")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#Methods"},"Methods"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#fireBullet"},"FireBullet()")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#bindCustomCast"},"BindCustomCast")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#bindShouldFire"},"BindShouldFire")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#Events"},"Events"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#BulletHit"},"BulletHit")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#BulletHitHumanoid"},"BulletHitHumanoid")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#BulletUpdated"},"BulletUpdated"))))),(0,a.kt)("h2",{id:"constructor"},"Constructor"),(0,a.kt)("p",null,"EasyBullet is a singleton so it will only be constructed once per server or client, but any subsequent calls to EasyBullet.new() will return the constructed singleton. Only the settings table passed to the first constructor will be used."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local EasyBulletSettingsOverrides = {\n    BulletColor = Color3.new(1, 0, 0),\n    Gravity = false\n}\n\nlocal easyBullet = EasyBullet.new(EasyBulletSettingsOverrides)\n")),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("h3",{id:"fireBullet"},"FireBullet()"),(0,a.kt)("p",null,"The primary method used to interact with EasyBullet. It fires a single bullet, and can be called on both the client, and the server. Call FireBullet() on the client to fire a bullet for a player, or on the server to fire a bullet for a NPC."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local direction = mouse.Hit.Position - gun.BarrelPosition\nlocal velocity = direction.Unit * 400\n\nlocal optionalEasyBulletSettings = {\n    BulletThickness = .4,\n    BulletData = {\n        BulletType = "AK47"\n    }\n}\n\neasyBullet:FireBullet(gun.BarrelPosition, velocity, optionalEasyBulletSettings)\n')),(0,a.kt)("h3",{id:"bindCustomCast"},"BindCustomCast()"),(0,a.kt)("p",null,"Pass BindCustomCast() a callback that returns a RaycastResult, or nil, to implement custom raycast behavior, such as lag compensation for network delayed character positions, or SphereCast for larger projectiles such as cannonballs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet:BindCustomCast(function(shooter: Player?, lastFramePosition: Vector3, thisFramePosition: Vector3, elapsedTime: number, bulletData: {[string]: Unknown})\n    local direction = lastFramePosition - thisFramePosition\n\n    local raycastParams = RaycastParams.new()\n\n    -- npc shots have no shooting player\n    if shooter then\n        raycastParams.FilterDescendantsInstances = {shooter.Character}\n        raycastParams.FilterType = Enum.RaycastFilterType.Exclude\n    end\n\n    return workspace:Raycast(lastFramePosition, direction, raycastParams)\nend)\n")),(0,a.kt)("p",null,"pass a callback that returns a boolean to provide a means of filtering bullets before they're fired. This doesn't prevent the bullet from being networked (see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ZachCurtis/EasyBullet/issues/2"},"#2"),"), so ",(0,a.kt)("inlineCode",{parentName:"p"},"BindShouldFire")," should only be called on the Server"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet:BindShouldFire(function(shooter: Player?, barrelPosition: Vector3, velocity: Vector3, ping: number, easyBulletSettings: Bullet.EasyBulletSettings?)\n    if not shooter or not shooter.Character or not shooter.Character.HumanoidRootPart then\n        return false\n    end\n\n    local humanoid = shooter.Character.Humanoid\n    local rootPart = shooter.Character.HumanoidRootPart\n\n    local discrepancy = (barrelPosition - rootPart.Position).Magnitude\n    local desyncTolerance = (shooter:GetNetworkPing() * humanoid.WalkSpeed) * 1.2\n\n    -- return true if barrelPosition is within how far the player could have walked in that time\n    return discrepancy <= desyncTolerance\nend)\n")),(0,a.kt)("h3",{id:"bindShouldFire"},"BindShouldFire()"),(0,a.kt)("p",null,"Pass this BindShouldFire() a callback that returns a boolean to provide a means of filtering bullets before they're fired. The bullet will initially be networked before the ShouldFire callback is called, but the bullet will automatically clean it's self up across the network if the ShouldFire callback returns false."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet:BindShouldFire(function(shooter: Player?, barrelPosition: Vector3, velocity: Vector3, ping: number, easyBulletSettings: Bullet.EasyBulletSettings?)\n    if not shooter or not shooter.Character or not shooter.Character.HumanoidRootPart then\n        return false\n    end\n\n    local humanoid = shooter.Character.Humanoid\n    local rootPart = shooter.Character.HumanoidRootPart\n\n    local discrepancy = (barrelPosition - rootPart.Position).Magnitude\n    local desyncTolerance = (shooter:GetNetworkPing() * humanoid.WalkSpeed) * 1.2\n\n    -- return true if barrelPosition is within how far the player could have walked in that time\n    return discrepancy <= desyncTolerance\nend)\n")),(0,a.kt)("h2",{id:"events"},"Events"),(0,a.kt)("h3",{id:"bullethit"},"BulletHit"),(0,a.kt)("p",null,"This event is fired whenever a bullet hits something."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet.BulletHit:Connect(function(shootingPlayer: Player?, raycastResult: RaycastResult, bulletData: {[string]: Unknown} | {HitVelocity: Vector3})\n    print(raycastResult.Instance.Name)\nend)\n")),(0,a.kt)("h3",{id:"bullethithumanoid"},"BulletHitHumanoid"),(0,a.kt)("p",null,"This event is fired whenever a bullet hits a part belonging to a model with a child humanoid."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet.BulletHitHumanoid:Connect(function(shootingPlayer: Player?, raycastResult: RaycastResult, hitHumanoid: Humanoid, bulletData: {[string]: Unknown} | {HitVelocity: Vector3})\n    hitHumanoid:TakeDamage(15)\nend)\n")),(0,a.kt)("h3",{id:"bulletupdated"},"BulletUpdated"),(0,a.kt)("p",null,"This event is fired every time the bullet updates. Useful for rendering custom bullets."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"easyBullet.BulletUpdated:Connect(function(lastFramePosition: Vector3, thisFramePosition: Vector3, bulletData: {[string]: unknown})\n    local direction = lastFramePosition - thisFramePosition\n\n    bulletPart.Size = Vector3.new(.2, .2, direction.Magnitude)\n    bulletPart.CFrame = CFrame.lookAt(lastFramePosition, thisFramePosition) * CFrame.new(0,0, -direction.Magnitude * .5)\nend)\n")))}p.isMDXComponent=!0}}]);